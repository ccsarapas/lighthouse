% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/character.R
\name{str_c_narm}
\alias{str_c_narm}
\title{Concatenate strings with \code{NA} handling}
\usage{
str_c_narm(
  ...,
  sep = "",
  collapse = NULL,
  if_all_na = c("empty", "NA", "remove")
)
}
\arguments{
\item{...}{character vectors or vectors coercible to character. May also be a single data frame (to accommodate \code{dplyr::across()} and \code{pick()}).}

\item{sep}{separator to insert between input vectors.}

\item{collapse}{optional character string to combine results into a single string.}

\item{if_all_na}{what to do if \emph{all} values in a row are \code{NA}:
\itemize{
\item \code{"empty"}: (default) returns an empty string.
\item \code{"NA"}: returns \code{NA}.
\item \code{"remove"}: removes the row from the output.
}}
}
\value{
A character vector.
}
\description{
\code{str_c_narm} concatenates strings similar to \code{base::paste()} or \code{stringr::str_c()}, but with different \code{NA} handling. \code{NA}s are dropped row-wise prior to concatenation. See Details and Examples.
}
\details{
\code{str_c_narm()} provides alternative missing value handling compared to
\code{base::paste()} and \code{stringr::str_c()}. Given some vectors with missing
values:
\preformatted{
#> (dat <- tibble::tibble(v1 = c("a1", "b1", "c1", NA),
                      v2 = c("a2", NA, "c2", NA),
                      v3 = c("a3", "b3", NA, NA)))
# A tibble: 4 × 3
  v1    v2    v3
  <chr> <chr> <chr>
1 a1    a2    a3
2 b1    NA    b3
3 c1    c2    NA
4 NA    NA    NA
}

\code{paste()} and \code{paste0()} convert \code{NA}s to the string \code{"NA"} before concatenating:
\preformatted{
#> dplyr::mutate(dat, paste = paste(v1, v2, v3, sep = " | "))
# A tibble: 4 × 4
  v1    v2    v3    paste
  <chr> <chr> <chr> <chr>
1 a1    a2    a3    a1 | a2 | a3
2 b1    NA    b3    b1 | NA | b3
3 c1    c2    NA    c1 | c2 | NA
4 NA    NA    NA    NA | NA | NA
}

...while \code{stringr::str_c} returns \code{NA} if any value in a row is \code{NA}:
\preformatted{
#> dplyr::mutate(dat, str_c = stringr::str_c(v1, v2, v3, sep = " | "))
# A tibble: 4 × 4
  v1    v2    v3    str_c
  <chr> <chr> <chr> <chr>
1 a1    a2    a3    a1 | a2 | a3
2 b1    NA    b3    NA
3 c1    c2    NA    NA
4 NA    NA    NA    NA
}

In contrast, \code{str_c_narm()} removes \code{NAs} from each row before concatenating:
\preformatted{
#> dplyr::mutate(dat, str_c_narm = str_c_narm(v1, v2, v3, sep = " | "))
# A tibble: 4 × 4
  v1    v2    v3    str_c_narm
  <chr> <chr> <chr> <chr>
1 a1    a2    a3    "a1 | a2 | a3"
2 b1    NA    b3    "b1 | b3"
3 c1    c2    NA    "c1 | c2"
4 NA    NA    NA    ""
}

...with options for the case where all values in a row are \code{NA}:
\preformatted{
#> dplyr::mutate(dat, str_c_narm = str_c_narm(v1, v2, v3, sep = " | ", if_all_na = "NA"))
# A tibble: 4 × 4
  v1    v2    v3    str_c_narm
  <chr> <chr> <chr> <chr>
1 a1    a2    a3    a1 | a2 | a3
2 b1    NA    b3    b1 | b3
3 c1    c2    NA    c1 | c2
4 NA    NA    NA    NA
}
}
\examples{
str_c_narm(c("a", NA), c("b", "c"), sep = "_")
str_c_narm(c("a", NA), c("b", NA), if_all_na = "NA")

# compare behavior to `paste()` and `str_c()`
dat <- tibble::tibble(v1 = c("a1", "b1", "c1", NA),
                      v2 = c("a2", NA, "c2", NA),
                      v3 = c("a3", "b3", NA, NA))

dplyr::mutate(
  dat,
  paste = paste(v1, v2, v3, sep = " | "),
  str_c = stringr::str_c(v1, v2, v3, sep = " | "),
  str_c_narm = str_c_narm(v1, v2, v3, sep = " | ")
)

}
